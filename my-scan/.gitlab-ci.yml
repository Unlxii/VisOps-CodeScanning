stages:
  - setup
  - security_audit
  - build_artifact
  - container_scan
  - release

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "api"
    - if: $CI_PIPELINE_SOURCE == "pipeline"
    - if: $CI_PIPELINE_SOURCE == "web"

variables:
  GITLEAKS_VERSION: "v8.18.4"
  SEMGREP_VERSION: "latest"
  TRIVY_VERSION: "0.53.0"
  KANIKO_VERSION: "v1.23.1-debug"
  CRANE_VERSION: "debug"
  
  PROJECT_NAME: "${PROJECT_NAME:-scanned-project}"
  USER_TAG: "${USER_TAG:-latest}"
  IMAGE_NAME: "index.docker.io/$DOCKER_USER/$PROJECT_NAME"
  TEMP_IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"
  TRIVY_CACHE_DIR: ".trivycache/"
  TRIVY_NO_PROGRESS: "true"

# --- Clone Template ---
.clone_logic: &clone_and_fix
  - echo "Initializing Git logic..."
  - if [ -z "$USER_REPO_URL" ]; then echo "USER_REPO_URL is missing"; exit 1; fi
  - if ! command -v git &> /dev/null; then apk add --no-cache git; fi
  
  - |
    if [ -n "$GIT_USERNAME" ] && [ -n "$GIT_TOKEN" ]; then
      echo "Private Repository detected. Authenticating..."
      CLEAN_URL=$(echo "$USER_REPO_URL" | sed -e 's|^https://||' -e 's|^http://||')
      git clone "https://${GIT_USERNAME}:${GIT_TOKEN}@${CLEAN_URL}" project_temp
    else
      echo "Public Repository detected (or no creds provided)."
      git clone "$USER_REPO_URL" project_temp
    fi

  - rm -rf .git
  - mv project_temp/.git .
  - cp -a project_temp/. . 
  - rm -rf project_temp
  - echo "Code cloned successfully."

# 1. Fetch Source
fetch_source_minified:
  stage: setup
  image:
    name: alpine/git:2.45.2
    entrypoint: [""]
  retry: 2
  script:
    - *clone_and_fix
    - echo "Removing .git history..."
    - rm -rf .git
  artifacts:
    paths: ["."]
    expire_in: 1 hour

# 2. Gitleaks
gitleaks_scan:
  stage: security_audit
  image:
    name: zricethezav/gitleaks:$GITLEAKS_VERSION
    entrypoint: [""]
  retry: 2
  script:
    - *clone_and_fix
    - echo "Scanning for secrets..."
    - gitleaks detect --source . -v --report-path gitleaks-report.json --exit-code 0
  allow_failure: true
  artifacts:
    paths: [gitleaks-report.json]
    when: always

# 3. Semgrep
semgrep_scan:
  stage: security_audit
  image:
    name: returntocorp/semgrep:$SEMGREP_VERSION
    entrypoint: [""]
  retry: 2
  script:
    - *clone_and_fix
    - echo "Scanning code vulnerabilities..."
    - semgrep scan --config=p/ci --json --output=semgrep-report.json --metrics=off --verbose .
  allow_failure: true
  artifacts:
    paths: [semgrep-report.json]
    when: always

# 4. Build & Push
build_and_push:
  stage: build_artifact
  image:
    name: gcr.io/kaniko-project/executor:$KANIKO_VERSION
    entrypoint: [""]
  script:
    - echo "Starting Build Process..."
    
    # Context Path Setup
    - export CONTEXT_PATH="${BUILD_CONTEXT:-.}"
    - echo "Build Context is $CONTEXT_PATH"

    - echo "Checking content..."
    - ls -la

    # Dockerfile Logic Block
    - |
      if [ -f "Dockerfile.manual" ]; then
        echo "Found Custom Dockerfile from Web Form."
        if [ "$CONTEXT_PATH" != "." ]; then
           echo "Moving Dockerfile.manual to $CONTEXT_PATH/Dockerfile..."
           mkdir -p "$CONTEXT_PATH"
           mv Dockerfile.manual "$CONTEXT_PATH/Dockerfile"
        else
           mv Dockerfile.manual Dockerfile
        fi
      elif [ -f "$CONTEXT_PATH/Dockerfile" ]; then
        echo "Found Dockerfile in Repository at $CONTEXT_PATH."
        echo "Using existing file."
      else
        echo "No Dockerfile found. Auto-detecting Stack..."
        if [ "$CONTEXT_PATH" != "." ] && [ -d "$CONTEXT_PATH" ]; then
           cd "$CONTEXT_PATH"
        fi
        
        STACK="default"
        if [ -f "package.json" ]; then STACK="node"; fi
        if [ -f "requirements.txt" ] || [ -f "Pipfile" ]; then STACK="python"; fi
        if [ -f "pom.xml" ]; then STACK="java"; fi
        if [ -f "go.mod" ]; then STACK="go"; fi
        
        echo "Detected Stack is $STACK"
        
        if [ "$CONTEXT_PATH" != "." ]; then cd -; fi

        if [ -z "$BACKEND_HOST_URL" ]; then echo "Error Backend URL missing"; exit 1; fi

        echo "Fetching Template..."
        wget --header="x-api-key: $API_KEY" -O Dockerfile_temp "$BACKEND_HOST_URL/api/templates?stack=$STACK"
        
        if [ ! -s Dockerfile_temp ]; then echo "Error fetching template"; exit 1; fi
        
        if [ "$CONTEXT_PATH" != "." ]; then
           mv Dockerfile_temp "$CONTEXT_PATH/Dockerfile"
        else
           mv Dockerfile_temp Dockerfile
        fi
        echo "Template setup complete."
      fi

    # Kaniko Execution
    - echo "Building Image..."
    - mkdir -p /kaniko/.docker
    - AUTH_STR=$(echo -n "$DOCKER_USER:$DOCKER_PASSWORD" | base64 | tr -d '\n')
    - echo "{\"auths\":{\"https://index.docker.io/v1/\":{\"auth\":\"$AUTH_STR\"},\"index.docker.io\":{\"auth\":\"$AUTH_STR\"}}}" > /kaniko/.docker/config.json
    
    #  FIX: ใช้ Backslash แทน >- เพื่อความชัวร์เรื่อง Syntax
    - /kaniko/executor
      --context "$CI_PROJECT_DIR/$CONTEXT_PATH"
      --dockerfile "$CI_PROJECT_DIR/$CONTEXT_PATH/Dockerfile"
      --destination "$IMAGE_NAME:$TEMP_IMAGE_TAG"
      --cache=true

# 5. Trivy Scan
trivy_scan:
  stage: container_scan
  image:
    name: aquasec/trivy:$TRIVY_VERSION
    entrypoint: [""]
  variables:
    TRIVY_USERNAME: "$DOCKER_USER"
    TRIVY_PASSWORD: "$DOCKER_PASSWORD"
    TRIVY_CACHE_DIR: ".trivycache/"
  cache:
    key: trivy-db-cache-protected
    paths: [.trivycache/]
    policy: pull-push
  retry: 2
  script:
    - echo "Preparing Container Scan..."
    - if ! command -v wget &> /dev/null; then apk add --no-cache wget; fi
    - wget https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl -O html.tpl
    
    - echo "Scanning Remote Image..."
    - trivy image --format template --template "@html.tpl" -o trivy-report.html --scanners vuln "$IMAGE_NAME:$TEMP_IMAGE_TAG"
    - trivy image --format json -o trivy-report.json --scanners vuln "$IMAGE_NAME:$TEMP_IMAGE_TAG"
  allow_failure: true
  artifacts:
    paths: [trivy-report.json, trivy-report.html]
    when: always

# 6. Release & Webhook
push_to_hub:
  stage: release
  image:
    name: gcr.io/go-containerregistry/crane:$CRANE_VERSION
    entrypoint: [""]
  retry: 2
  dependencies: [trivy_scan]
  script:
    - echo "Promoting image..."
    - if [ -z "$DOCKER_USER" ]; then echo "No Docker Creds Skipping."; exit 0; fi
    
    # Check Critical Vulns
    - |
      CRITICAL_COUNT=0
      if [ -f trivy-report.json ]; then
        CRITICAL_COUNT=$(grep -c "Severity.*CRITICAL" trivy-report.json || true)
      fi
      CRITICAL_COUNT=$(echo $CRITICAL_COUNT | tr -d ' ')
      [ -z "$CRITICAL_COUNT" ] && CRITICAL_COUNT=0
      
      echo "Found $CRITICAL_COUNT critical vulnerabilities."

      TARGET_TAG="$USER_TAG"
      if [ "$CRITICAL_COUNT" -gt 0 ]; then
        echo "CRITICAL ISSUES FOUND Appending warning."
        TARGET_TAG="${USER_TAG}-warning"
      fi

      echo "Final Image is $IMAGE_NAME:$TARGET_TAG"
      
      crane auth login -u "$DOCKER_USER" -p "$DOCKER_PASSWORD" index.docker.io
      crane cp "$IMAGE_NAME:$TEMP_IMAGE_TAG" "$IMAGE_NAME:$TARGET_TAG"
      crane delete "$IMAGE_NAME:$TEMP_IMAGE_TAG" || echo "Warning Failed cleanup."
      
      # Webhook
      if command -v curl &> /dev/null; then
        curl -X POST -H "Content-Type: application/json" \
        -d "{\"scanId\": \"$CI_PROJECT_ID\", \"status\": \"SUCCESS\", \"vulnCritical\": $CRITICAL_COUNT}" \
        "$BACKEND_HOST_URL/api/scan/webhook"
      else
        wget --header="Content-Type: application/json" \
        --post-data="{\"scanId\": \"$CI_PROJECT_ID\", \"status\": \"SUCCESS\", \"vulnCritical\": $CRITICAL_COUNT}" \
        "$BACKEND_HOST_URL/api/scan/webhook"
      fi

  when: manual