stages:
  - setup
  - security_audit
  - build_artifact
  - container_scan
  - release
  - cleanup

workflow:
  name: "Scan: $PROJECT_NAME (Tag: $USER_TAG) by $GIT_USERNAME"
  rules:
    - if: $CI_PIPELINE_SOURCE == "api"
    - if: $CI_PIPELINE_SOURCE == "pipeline"
    - if: $CI_PIPELINE_SOURCE == "web"

variables:
  GITLEAKS_VERSION: "v8.18.4"
  SEMGREP_VERSION: "latest"
  TRIVY_VERSION: "0.53.0"
  KANIKO_VERSION: "v1.23.1-debug"
  CRANE_VERSION: "debug"
  
  PROJECT_NAME: "${PROJECT_NAME:-scanned-project}"
  USER_TAG: "${USER_TAG:-latest}"
  IMAGE_NAME: "docker.io/$DOCKER_USER/$PROJECT_NAME"
  TEMP_IMAGE_TAG: "temp-$CI_PIPELINE_ID"
  
  TRIVY_CACHE_DIR: ".trivycache/"
  TRIVY_NO_PROGRESS: "true"

# 1. Fetch Source 
fetch_source_minified:
  stage: setup
  image:
    name: alpine/git:2.45.2
    entrypoint: [""]
  retry: 2
  script:
    - |
      echo "Pipeline Started..."
      
      # Install dependencies
      if ! command -v wget &> /dev/null; then apk add --no-cache wget; fi
      
      # 1. à¸¢à¸´à¸‡ Webhook à¹à¸ˆà¹‰à¸‡à¸ªà¸–à¸²à¸™à¸° RUNNING
      echo "ðŸ“¡ Sending Webhook to: $BACKEND_HOST_URL/api/webhook"
      wget --header="Content-Type: application/json" \
           --post-data="{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"RUNNING\"}" \
           "$BACKEND_HOST_URL/api/webhook" || echo "Webhook Warning"

      echo "Initializing Git logic..."
      if [ -z "$USER_REPO_URL" ]; then echo "USER_REPO_URL is missing"; exit 1; fi
      
      # 2. Clone Project à¸‚à¸­à¸‡ user à¸¡à¸²à¸¥à¸‡à¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œ temp
      if [ -n "$GIT_USERNAME" ] && [ -n "$GIT_TOKEN" ]; then
        echo "Private Repo detected..."
        CLEAN_URL=$(echo "$USER_REPO_URL" | sed -e 's|^https://||' -e 's|^http://||')
        git clone "https://${GIT_USERNAME}:${GIT_TOKEN}@${CLEAN_URL}" project_temp
      else
        echo "Public Repo detected..."
        git clone "$USER_REPO_URL" project_temp
      fi
      
      # 3.à¹à¸à¹‰ Error Directory not empty
      rm -rf .git
      
      # 4. à¸¢à¹‰à¸²à¸¢ .git à¸‚à¸­à¸‡ User à¸¡à¸²à¹ƒà¸ªà¹ˆ à¹à¸¥à¸° Copy à¹„à¸Ÿà¸¥à¹Œà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¸­à¸­à¸à¸¡à¸²
      mv project_temp/.git .
      cp -a project_temp/. . 
      rm -rf project_temp
      
      echo "Code cloned successfully."
      
      # 5. Debug: à¹‚à¸Šà¸§à¹Œà¹ƒà¸«à¹‰à¸”à¸¹à¸§à¹ˆà¸²à¹ƒà¸™ folder à¸¡à¸µà¸­à¸°à¹„à¸£à¸šà¹‰à¸²à¸‡ (à¹€à¸žà¸·à¹ˆà¸­à¸„à¸§à¸²à¸¡à¸Šà¸±à¸§à¸£à¹Œ)
      ls -la
  artifacts:
    paths: ["."]
    expire_in: 1 hour

# 2. Gitleaks (à¹à¸à¹‰: à¸ªà¹à¸à¸™ History + à¸ªà¹ˆà¸‡à¸œà¸¥à¹€à¸‚à¹‰à¸² Webhook)
gitleaks_scan:
  stage: security_audit
  image:
    name: zricethezav/gitleaks:$GITLEAKS_VERSION
    entrypoint: [""]
  needs: ["fetch_source_minified"]
  script:
    - echo "Gitleaks Scanning..."
    - apk add --no-cache jq curl
    
    - gitleaks detect --source . -v --report-path gitleaks-report.json --exit-code 0
    
    - |
      if [ -f gitleaks-report.json ]; then
        echo "Parsing Gitleaks results with Author info..."
        
        FINDINGS=$(jq '[.[] | {
            id: .RuleID, 
            severity: "critical", 
            title: ("Secret Found: " + .Description + " (by " + .Author + ")"), 
            pkgName: .File, 
            sourceTool: "Gitleaks",
            author: .Author,
            email: .Email,
            commit: .Commit,
            message: .Message
        }]' gitleaks-report.json)
        
        # à¸ªà¹ˆà¸‡ Webhook
        curl -X POST -H "Content-Type: application/json" \
        -d "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"RUNNING\", \"details\": {\"findings\": $FINDINGS}}" \
        "$BACKEND_HOST_URL/api/webhook" || echo "Webhook failed"
      fi
  allow_failure: true
  artifacts:
    paths: [gitleaks-report.json]

# 3. Semgrep (à¹à¸à¹‰: à¸ªà¹ˆà¸‡à¸œà¸¥à¹€à¸‚à¹‰à¸² Webhook)
semgrep_scan:
  stage: security_audit
  image:
    name: returntocorp/semgrep:$SEMGREP_VERSION
    entrypoint: [""]
  needs: ["fetch_source_minified"]
  script:
    - echo "Semgrep Scanning..."
    # install curl & jq inside Semgrep container (alpine based)
    - if ! command -v jq &> /dev/null; then apk add --no-cache jq curl || true; fi

    - semgrep scan --config=p/ci --json --output=semgrep-report.json --metrics=off . || true
    
    - |
      if [ -f semgrep-report.json ]; then
        echo "Parsing Semgrep results..."
        # à¹à¸›à¸¥à¸‡ Severity: ERROR->high, WARNING->medium
        FINDINGS=$(jq '[.results[] | {id: .check_id, severity: (if .extra.severity == "ERROR" then "high" else "medium" end), title: .extra.message, pkgName: .path, sourceTool: "Semgrep"}]' semgrep-report.json)
        
        curl -X POST -H "Content-Type: application/json" \
        -d "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"RUNNING\", \"details\": {\"findings\": $FINDINGS}}" \
        "$BACKEND_HOST_URL/api/webhook" || echo "Webhook failed"
      fi
  allow_failure: true
  artifacts:
    paths: [semgrep-report.json]

# 4. Build & Push (à¹€à¸«à¸¡à¸·à¸­à¸™à¹€à¸”à¸´à¸¡ à¹à¸•à¹ˆà¸›à¸´à¸” Cache à¹€à¸žà¸·à¹ˆà¸­ Auto-create Repo)
build_and_push:
  stage: build_artifact
  image:
    name: gcr.io/kaniko-project/executor:$KANIKO_VERSION
    entrypoint: [""]
  needs: ["fetch_source_minified"]
  script:
    - |
      echo "Starting Build..."
      if [ -z "$DOCKER_USER" ]; then echo "No Docker Creds"; exit 1; fi
      
      export IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"
      export CONTEXT_PATH="${BUILD_CONTEXT:-.}"
      
      # ... (Logic Dockerfile Auto-detect à¹€à¸”à¸´à¸¡à¸‚à¸­à¸‡à¸„à¸¸à¸“ à¹ƒà¸ªà¹ˆà¸•à¸£à¸‡à¸™à¸µà¹‰) ...
      if [ -f "Dockerfile.manual" ]; then
         mkdir -p "$CONTEXT_PATH"; mv Dockerfile.manual "$CONTEXT_PATH/Dockerfile"
      elif [ ! -f "$CONTEXT_PATH/Dockerfile" ]; then
         if [ "$CONTEXT_PATH" != "." ] && [ -d "$CONTEXT_PATH" ]; then cd "$CONTEXT_PATH"; fi
         STACK="default"
         if [ -f "package.json" ]; then STACK="node"; fi
         if [ -f "requirements.txt" ] || [ -f "Pipfile" ]; then STACK="python"; fi
         if [ -f "go.mod" ]; then STACK="go"; fi
         if [ "$CONTEXT_PATH" != "." ]; then cd -; fi
         
         wget --header="x-api-key: $API_KEY" -O Dockerfile_temp "$BACKEND_HOST_URL/api/templates?stack=$STACK"
         mkdir -p "$CONTEXT_PATH"; mv Dockerfile_temp "$CONTEXT_PATH/Dockerfile"
      fi

      mkdir -p /kaniko/.docker
      AUTH_STR=$(echo -n "$DOCKER_USER:$DOCKER_PASSWORD" | base64 | tr -d '\n')
      echo "{\"auths\":{\"https://index.docker.io/v1/\":{\"auth\":\"$AUTH_STR\"},\"index.docker.io\":{\"auth\":\"$AUTH_STR\"}}}" > /kaniko/.docker/config.json
      
      /kaniko/executor \
        --context "$CI_PROJECT_DIR/$CONTEXT_PATH" \
        --dockerfile "$CI_PROJECT_DIR/$CONTEXT_PATH/Dockerfile" \
        --destination "$IMAGE_NAME:$TEMP_IMAGE_TAG" \
        --cache=false

# 5. Trivy Scan (à¹à¸à¹‰: à¸ªà¹ˆà¸‡à¸œà¸¥à¹€à¸‚à¹‰à¸² Webhook)
trivy_scan:
  stage: container_scan
  image:
    name: aquasec/trivy:$TRIVY_VERSION
    entrypoint: [""]
  needs: ["build_and_push"]
  variables:
    TRIVY_USERNAME: "$DOCKER_USER"
    TRIVY_PASSWORD: "$DOCKER_PASSWORD"
    TRIVY_AUTH_URL: "https://index.docker.io/v1/"
    TRIVY_CACHE_DIR: ".trivycache/"
    TRIVY_NO_PROGRESS: "true"
  
  cache:
    key: trivy-db-cache-protected
    paths:
      - .trivycache/
    policy: pull-push
    
  script:
    # à¹ƒà¸Šà¹‰ Single Quote à¸„à¸£à¸­à¸šà¸„à¸³à¸ªà¸±à¹ˆà¸‡ export à¹€à¸žà¸·à¹ˆà¸­à¸„à¸§à¸²à¸¡à¸Šà¸±à¸§à¸£à¹Œà¹€à¸£à¸·à¹ˆà¸­à¸‡à¸­à¸±à¸à¸‚à¸£à¸°à¸žà¸´à¹€à¸¨à¸©
    - 'export IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"'
    
    # à¹ƒà¸Šà¹‰ Single Quote à¸„à¸£à¸­à¸šà¸”à¹‰à¸²à¸™à¸™à¸­à¸à¸ªà¸¸à¸” à¹à¸¥à¹‰à¸§ Double Quote à¸”à¹‰à¸²à¸™à¹ƒà¸™ à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰ Variable à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰à¹à¸¥à¸° YAML à¹„à¸¡à¹ˆà¸žà¸±à¸‡
    - 'echo "Target Image: $IMAGE_NAME:$TEMP_IMAGE_TAG"'
    
    # Install dependencies
    - |
      if ! command -v curl &> /dev/null; then 
        apk add --no-cache curl jq
      fi
    
    # Optional: Download template (à¸–à¹‰à¸² Error à¹ƒà¸«à¹‰à¸‚à¹‰à¸²à¸¡à¹„à¸”à¹‰)
    - wget https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl -O html.tpl || true

    # à¸¥à¹‰à¸²à¸‡ Cache à¸à¸²à¸£à¸ªà¹à¸à¸™ (à¹à¸•à¹ˆà¹€à¸à¹‡à¸š DB à¹„à¸§à¹‰)
    - trivy clean --scan-cache || true
    
    - echo "Trivy Scanning (Timeout 20m)..."
    
    # Scan 1: HTML Report
    - 'trivy image --timeout 20m --scanners vuln --format template --template "@html.tpl" -o trivy-report.html "$IMAGE_NAME:$TEMP_IMAGE_TAG"'
    
    # Scan 2: JSON Report & Webhook
    - 'trivy image --timeout 20m --scanners vuln --format json -o trivy-report.json "$IMAGE_NAME:$TEMP_IMAGE_TAG"'
    
    # Webhook Logic
    - |
      if [ -f trivy-report.json ]; then
        echo "Parsing Trivy results..."
        FINDINGS=$(jq '[.Results[]?.Vulnerabilities[]? | {id: .VulnerabilityID, severity: (.Severity | ascii_downcase), title: .Title, pkgName: .PkgName, installedVersion: .InstalledVersion, fixedVersion: .FixedVersion, sourceTool: "Trivy"}]' trivy-report.json)
        
        if [ -z "$FINDINGS" ] || [ "$FINDINGS" == "null" ]; then FINDINGS="[]"; fi

        curl -X POST -H "Content-Type: application/json" \
        -d "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"RUNNING\", \"details\": {\"findings\": $FINDINGS}}" \
        "$BACKEND_HOST_URL/api/webhook"
      else
        echo "Trivy Report not found!"
      fi
  
  allow_failure: true
  artifacts:
    paths: 
      - trivy-report.json
      - trivy-report.html
    when: always

# 6. Release (à¸ªà¹ˆà¸‡à¸ªà¸–à¸²à¸™à¸°à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢)
push_to_hub:
  stage: release
  image:
    name: gcr.io/go-containerregistry/crane:$CRANE_VERSION
    entrypoint: [""]
  needs: ["trivy_scan"]
  script:
    - export IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"
    - if ! command -v jq &> /dev/null; then apk add --no-cache jq curl; fi
    
    - CRITICAL_COUNT=0
    - if [ -f trivy-report.json ]; then CRITICAL_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-report.json); fi
    
    - |
      if [ "$CRITICAL_COUNT" -gt 0 ]; then
         echo "BLOCKED by Security"
         curl -X POST -H "Content-Type: application/json" \
         -d "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"BLOCKED\", \"vulnCritical\": $CRITICAL_COUNT}" \
         "$BACKEND_HOST_URL/api/webhook"
         exit 1
      fi
      
      echo "Promoting Image..."
      crane auth login -u "$DOCKER_USER" -p "$DOCKER_PASSWORD" index.docker.io
      crane cp "$IMAGE_NAME:$TEMP_IMAGE_TAG" "$IMAGE_NAME:$USER_TAG"
      crane delete "$IMAGE_NAME:$TEMP_IMAGE_TAG"
      
      curl -X POST -H "Content-Type: application/json" \
      -d "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"SUCCESS\"}" \
      "$BACKEND_HOST_URL/api/webhook"
  when: manual

notify_failure:
  stage: cleanup
  image:
    name: curlimages/curl:latest
    entrypoint: [""]
  script:
    - echo "Pipeline Failed! Sending Webhook..."
    - |
      curl -X POST -H "Content-Type: application/json" \
      -d "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"FAILED\"}" \
      "$BACKEND_HOST_URL/api/webhook"
  when: on_failure

# Job à¹€à¸”à¸´à¸¡ (à¸¥à¸š Image à¸Šà¸±à¹ˆà¸§à¸„à¸£à¸²à¸§)
cleanup_temp_image:
  stage: cleanup
  image:
    name: gcr.io/go-containerregistry/crane:$CRANE_VERSION
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none 
  script:
    - echo "Ensuring cleanup..."
    - if [ -z "$DOCKER_USER" ]; then exit 0; fi
    - export IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"
    - crane auth login -u "$DOCKER_USER" -p "$DOCKER_PASSWORD" index.docker.io
    - crane delete "$IMAGE_NAME:$TEMP_IMAGE_TAG" || true
  when: always 

