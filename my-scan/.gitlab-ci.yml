stages:
  - maintenance
  - setup
  - security_audit
  - compile
  - build_artifact
  - container_scan
  - release
  - cleanup

workflow:
  name: "Scan: $PROJECT_NAME (Tag: $USER_TAG) by $GIT_USERNAME"
  rules:
    - if: $CI_PIPELINE_SOURCE == "api"
    - if: $CI_PIPELINE_SOURCE == "pipeline"
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_PIPELINE_SOURCE == "schedule"

variables:
  # Tool Versions
  GITLEAKS_VERSION: "v8.18.4"
  SEMGREP_VERSION: "latest"
  TRIVY_VERSION: "0.53.0"
  KANIKO_VERSION: "v1.23.1-debug"
  CRANE_VERSION: "debug"
  MAVEN_VERSION: "3.9-eclipse-temurin-21"
  GRADLE_VERSION: "8-jdk21"
  NODE_VERSION: "20-alpine"
  GO_VERSION: "1.22-alpine"
  PYTHON_VERSION: "3.12-alpine"

  # Project Settings
  PROJECT_NAME: "${PROJECT_NAME:-scanned-project}"
  USER_TAG: "${USER_TAG:-latest}"
  IMAGE_NAME: "docker.io/$DOCKER_USER/$PROJECT_NAME"
  TEMP_IMAGE_TAG: "temp-$CI_PIPELINE_ID"

  # Dynamic Path Configuration
  # If TARGET_DIR is set (e.g., "backend"), the pipeline will force scan only that directory.
  # If empty, it attempts to auto-detect source code priority.
  TARGET_DIR: ""

  # Backend Configuration
  ENABLE_WEBHOOKS: "${ENABLE_WEBHOOKS:-true}"
  WEBHOOK_TIMEOUT: "5"

  # Security Scanning Configuration
  TRIVY_SCAN_MODE: "${TRIVY_SCAN_MODE:-fast}"

  # Cache & Performance
  TRIVY_CACHE_DIR: ".trivycache/"
  TRIVY_NO_PROGRESS: "true"
  MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  GRADLE_USER_HOME: ".gradle"

# ==================================================
# 0. Nightly Maintenance - Update Trivy DB
# ==================================================
update_trivy_db:
  stage: maintenance
  image:
    name: aquasec/trivy:$TRIVY_VERSION
    entrypoint: [""]
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
      allow_failure: true
  cache:
    key: trivy-global-cache
    paths:
      - .trivycache/
    policy: pull-push
  script:
    - echo "Nightly Trivy DB Update Job"
    - echo "========================================"
    - echo "Updating vulnerability database..."

    - |
      if [ -f ".trivycache/db/metadata.json" ]; then
        DB_AGE=$(( $(date +%s) - $(stat -c %Y .trivycache/db/metadata.json 2>/dev/null || echo 0) ))
        echo "Current cache age: $(($DB_AGE / 3600))h"
      else
        echo "No existing cache"
      fi

    - |
      trivy image --download-db-only --cache-dir .trivycache/ && {
        echo "DB update completed successfully"
      } || {
        echo "DB update failed"
        exit 1
      }
  artifacts:
    paths:
      - .trivycache/
    expire_in: 2 days

# ==================================================
# 1. Fetch Source & Smart Detect (Root vs Nested)
# ==================================================
fetch_and_detect:
  stage: setup
  image:
    name: alpine/git:2.45.2
    entrypoint: [""]
  retry: 2
  script:
    - echo "Pipeline Started... Initializing..."
    - if ! command -v wget &> /dev/null; then apk add --no-cache wget; fi

    # Smart Webhook Function
    - >
      send_webhook() {
        local payload="$1"
        local output_file="${2:-webhook_payload.json}"
        echo "$payload" > "$output_file"
        
        if [ "$ENABLE_WEBHOOKS" != "true" ]; then
          echo "Webhooks disabled - Payload saved"
          return 0
        fi
        
        if wget --timeout=$WEBHOOK_TIMEOUT --spider "$BACKEND_HOST_URL/api/webhook" 2>&1 | grep -q "200\|302\|404"; then
          echo "Backend accessible - Sending webhook..."
          wget --header="Content-Type: application/json" \
               --post-data="$payload" \
               --timeout=$WEBHOOK_TIMEOUT \
               "$BACKEND_HOST_URL/api/webhook" -O - || echo "Webhook request failed"
        else
          echo "Backend unreachable (offline mode)"
        fi
      }

    - |
      send_webhook "{\"pipelineId\": \"$CI_PIPELINE_ID\", \"status\": \"RUNNING\"}" "pipeline_start.json"

    # Git Clone Logic
    - echo "Initializing Git logic..."
    - if [ -z "$USER_REPO_URL" ]; then echo "USER_REPO_URL is missing"; exit 1; fi

    - |
      if [ -n "$GIT_USERNAME" ] && [ -n "$GIT_TOKEN" ]; then
        CLEAN_URL=$(echo "$USER_REPO_URL" | sed -e 's|^https://||' -e 's|^http://||')
        git clone --depth 1 "https://${GIT_USERNAME}:${GIT_TOKEN}@${CLEAN_URL}" project_temp
      else
        git clone --depth 1 "$USER_REPO_URL" project_temp
      fi

    - rm -rf project_temp/.git
    - cp -a project_temp/. .
    - rm -rf project_temp

    # ============================================
    # SMART DETECTION LOGIC (Root vs Nested)
    # ============================================
    - |
      echo "Starting Smart Detection..."

      # Search priority: User override -> Root -> Standard folders
      SEARCH_PATHS="${TARGET_DIR:-. backend frontend api web src app}"

      DETECTED_PATH="."
      STACK="unknown"

      for path in $SEARCH_PATHS; do
        if [ -d "$path" ]; then
          echo "Checking path: $path"
          
          # Priority 1: Compiled Languages
          if [ -f "$path/pom.xml" ]; then 
            STACK="java-maven"; DETECTED_PATH="$path"; break;
          elif [ -f "$path/build.gradle" ] || [ -f "$path/build.gradle.kts" ]; then 
            STACK="java-gradle"; DETECTED_PATH="$path"; break;
          elif [ -f "$path/go.mod" ]; then 
            STACK="go"; DETECTED_PATH="$path"; break;
          elif [ -f "$path/Cargo.toml" ]; then 
            STACK="rust"; DETECTED_PATH="$path"; break;
            
          # Priority 2: Interpreted Languages (Only if compiled not found yet)
          elif [ -f "$path/package.json" ] && [ "$STACK" = "unknown" ]; then 
            STACK="node"; DETECTED_PATH="$path";
            # Continue loop in case a backend is found later (unless target_dir is set)
            if [ -n "$TARGET_DIR" ]; then break; fi
          elif ([ -f "$path/requirements.txt" ] || [ -f "$path/Pipfile" ] || [ -f "$path/pyproject.toml" ]) && [ "$STACK" = "unknown" ]; then 
            STACK="python"; DETECTED_PATH="$path";
             if [ -n "$TARGET_DIR" ]; then break; fi
          fi
        fi
      done

      # Ensure path doesn't have leading/trailing slashes for consistency
      DETECTED_PATH=$(echo "$DETECTED_PATH" | sed 's|^\./||;s|/$||')
      if [ -z "$DETECTED_PATH" ]; then DETECTED_PATH="."; fi

      echo "$STACK" > .detected_stack
      echo "$DETECTED_PATH" > .build_context

      echo "DETECTION RESULTS:"
      echo "   Stack: $STACK"
      echo "   Context: $DETECTED_PATH"

  artifacts:
    name: "source-code-$CI_PIPELINE_ID"
    paths:
      - "."
      - "*.json"
    exclude:
      - ".git/**/*"
      - "**/node_modules/**/*"
      - "**/.m2/**/*"
      - "**/.gradle/**/*"
    expire_in: 1 hour

# ==================================================
# 2. Security Audits
# ==================================================

gitleaks_scan:
  stage: security_audit
  image:
    name: zricethezav/gitleaks:$GITLEAKS_VERSION
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none
  needs: []
  script:
    - echo "Gitleaks Scanning (Full History Mode)..."
    - apk add --no-cache git jq curl
    - rm -rf * .git 2>/dev/null || true

    - |
      if [ -n "$GIT_USERNAME" ] && [ -n "$GIT_TOKEN" ]; then
        CLEAN_URL=$(echo "$USER_REPO_URL" | sed -e 's|^https://||' -e 's|^http://||')
        git clone "https://${GIT_USERNAME}:${GIT_TOKEN}@${CLEAN_URL}" .
      else
        git clone "$USER_REPO_URL" .
      fi

    - gitleaks detect --source . -v --report-path gitleaks-report.json --exit-code 0

    - |
      # Webhook Logic (Simplified for brevity, assumes send_webhook_smart logic similar to fetch)
      if [ -f gitleaks-report.json ] && [ "$ENABLE_WEBHOOKS" = "true" ]; then
        echo "Processing Gitleaks report..."
        # (JSON Parsing Logic would go here)
      fi
  allow_failure: true
  artifacts:
    paths:
      - gitleaks-report.json
    when: always

semgrep_scan:
  stage: security_audit
  image:
    name: returntocorp/semgrep:$SEMGREP_VERSION
    entrypoint: [""]
  needs: ["fetch_and_detect"]
  script:
    - echo "Semgrep Scanning..."
    - apk add --no-cache jq curl || true

    # Read context to scan relevant files only
    - CONTEXT_PATH=$(cat .build_context)
    - echo "Scanning context- $CONTEXT_PATH"

    - semgrep scan --config=p/ci --json --output=semgrep-report.json --metrics=off "$CONTEXT_PATH" || true
  allow_failure: true
  artifacts:
    paths:
      - semgrep-report.json
    when: always

# ==================================================
# 3. Compile Stage (Dynamic based on Detection)
# ==================================================

compile_java_maven:
  stage: compile
  image: maven:$MAVEN_VERSION
  needs: ["fetch_and_detect"]
  cache:
    key: maven-$CI_PROJECT_ID
    paths:
      - .m2/repository
    policy: pull-push
  script:
    - STACK=$(cat .detected_stack)
    - CONTEXT_PATH=$(cat .build_context)

    # Smart Skip
    - |
      if [ "$STACK" != "java-maven" ] && [ "$FORCE_STACK" != "java-maven" ]; then
        echo "Skipping: Detected stack is $STACK"
        exit 0
      fi

    - echo "Building Java Maven in- $CONTEXT_PATH"
    - cd "$CONTEXT_PATH"
    - mvn clean package -DskipTests -B -q

    - JAR_NAME=$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" -type f | head -1)
    - |
      if [ -n "$JAR_NAME" ]; then
        # Save absolute path or relative to root
        echo "$CONTEXT_PATH/$JAR_NAME" > ../.jar_path
        echo "JAR Found: $CONTEXT_PATH/$JAR_NAME"
      else
        echo "Error: No JAR found"
        exit 1
      fi
  artifacts:
    name: "compiled-maven-$CI_PIPELINE_ID"
    paths:
      - "."
    exclude:
      - ".git/**/*"
    expire_in: 1 hour

compile_java_gradle:
  stage: compile
  image: gradle:$GRADLE_VERSION
  needs: ["fetch_and_detect"]
  cache:
    key: gradle-$CI_PROJECT_ID
    paths:
      - .gradle/
    policy: pull-push
  script:
    - STACK=$(cat .detected_stack)
    - CONTEXT_PATH=$(cat .build_context)

    - |
      if [ "$STACK" != "java-gradle" ] && [ "$FORCE_STACK" != "java-gradle" ]; then
        echo "Skipping: Detected stack is $STACK"
        exit 0
      fi

    - echo "Building Java Gradle in- $CONTEXT_PATH"
    - cd "$CONTEXT_PATH"
    - gradle clean build -x test --no-daemon -q

    - JAR_NAME=$(find build/libs -name "*.jar" -not -name "*-plain.jar" -type f | head -1)
    - |
      if [ -n "$JAR_NAME" ]; then
        echo "$CONTEXT_PATH/$JAR_NAME" > ../.jar_path
        echo "JAR Found: $CONTEXT_PATH/$JAR_NAME"
      else
        echo "Error: No JAR found"
        exit 1
      fi
  artifacts:
    paths:
      - "."
    exclude:
      - ".git/**/*"
    expire_in: 1 hour

compile_go:
  stage: compile
  image: golang:$GO_VERSION
  needs: ["fetch_and_detect"]
  cache:
    key: go-$CI_PROJECT_ID
    paths:
      - .go/pkg/mod/
    policy: pull-push
  script:
    - STACK=$(cat .detected_stack)
    - CONTEXT_PATH=$(cat .build_context)

    - |
      if [ "$STACK" != "go" ] && [ "$FORCE_STACK" != "go" ]; then
        echo "Skipping: Detected stack is $STACK"
        exit 0
      fi

    - echo "Building Go in- $CONTEXT_PATH"
    - export GOPATH="$CI_PROJECT_DIR/.go"
    - cd "$CONTEXT_PATH"
    - go mod download
    - CGO_ENABLED=0 GOOS=linux go build -o app .
  artifacts:
    paths:
      - "."
    exclude:
      - ".git/**/*"
      - ".go/**/*"
    expire_in: 1 hour

compile_node:
  stage: compile
  image: node:$NODE_VERSION
  needs: ["fetch_and_detect"]
  cache:
    key: node-$CI_PROJECT_ID
    paths:
      - node_modules/
    policy: pull-push
  script:
    - STACK=$(cat .detected_stack)
    - CONTEXT_PATH=$(cat .build_context)

    - |
      if [ "$STACK" != "node" ] && [ "$FORCE_STACK" != "node" ]; then
        echo "Skipping: Detected stack is $STACK"
        exit 0
      fi

    - echo "Installing Node deps in- $CONTEXT_PATH"
    - cd "$CONTEXT_PATH"

    - |
      if [ -f "yarn.lock" ]; then
        yarn install --frozen-lockfile --silent
      else
        npm ci --silent || npm install --silent
      fi

    - |
      if grep -q '"build"' package.json; then
        npm run build || true
      fi
  artifacts:
    paths:
      - "."
    exclude:
      - ".git/**/*"
    expire_in: 1 hour

compile_python:
  stage: compile
  image: python:$PYTHON_VERSION
  needs: ["fetch_and_detect"]
  script:
    - STACK=$(cat .detected_stack)
    - |
      if [ "$STACK" != "python" ] && [ "$FORCE_STACK" != "python" ]; then
        echo "Skipping: Detected stack is $STACK"
        exit 0
      fi
    - echo "Python detected. Preparing artifacts..."
  artifacts:
    paths:
      - "."
    exclude:
      - ".git/**/*"
    expire_in: 1 hour

# ==================================================
# 4. Build Docker Image (Kaniko)
# ==================================================
build_and_push:
  stage: build_artifact
  image:
    name: gcr.io/kaniko-project/executor:$KANIKO_VERSION
    entrypoint: [""]
  needs:
    - job: fetch_and_detect
      artifacts: true
    - job: compile_java_maven
      artifacts: true
      optional: true
    - job: compile_java_gradle
      artifacts: true
      optional: true
    - job: compile_go
      artifacts: true
      optional: true
    - job: compile_node
      artifacts: true
      optional: true
    - job: compile_python
      artifacts: true
      optional: true
  script:
    - echo "Starting Docker Build..."
    - if [ -z "$DOCKER_USER" ]; then echo "No Docker Creds"; exit 1; fi

    # Read Context Info
    - STACK=$(cat .detected_stack)
    - CONTEXT_PATH=$(cat .build_context)
    - IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"

    - echo "Building Context- $CONTEXT_PATH"
    - echo "Stack- $STACK"

    # Dockerfile Determination Logic - RESPECT USER'S DOCKERFILE
    - DOCKERFILE_PATH="$CONTEXT_PATH/Dockerfile"

    - |
      echo "========================================="
      echo "DOCKERFILE DETECTION STRATEGY"
      echo "Context Path: $CONTEXT_PATH"
      echo "Searching for Dockerfile..."
      echo "========================================="

      # Priority 1: Dockerfile.manual (highest priority - user override)
      if [ -f "Dockerfile.manual" ]; then
        echo "âœ… USING: Dockerfile.manual (user-provided override)"
        mkdir -p "$CONTEXT_PATH"
        cp Dockerfile.manual "$DOCKERFILE_PATH"
        
      # Priority 2: Dockerfile in context path (most specific)
      elif [ -f "$DOCKERFILE_PATH" ]; then
        echo "âœ… USING: $DOCKERFILE_PATH (service-specific Dockerfile)"
        
      # Priority 3: Dockerfile in context path (check variations)
      elif [ "$CONTEXT_PATH" != "." ] && [ -f "$CONTEXT_PATH/Dockerfile" ]; then
        echo "âœ… USING: $CONTEXT_PATH/Dockerfile (service-specific)"
        DOCKERFILE_PATH="$CONTEXT_PATH/Dockerfile"
        
      # Priority 4: Dockerfile in root directory (for monorepo multi-stage builds)
      elif [ -f "Dockerfile" ]; then
        echo "âœ… USING: Root Dockerfile (monorepo/multi-stage build)"
        if [ "$CONTEXT_PATH" != "." ]; then
          echo "   Note: Building with root Dockerfile, context=$CONTEXT_PATH"
          # Keep root Dockerfile path but set context correctly
          DOCKERFILE_PATH="Dockerfile"
        else
          DOCKERFILE_PATH="Dockerfile"
        fi
        
      # Priority 5: ONLY generate if NO Dockerfile exists anywhere
      else
        echo "âš ï¸  NO DOCKERFILE FOUND - Generating basic template for $STACK"
        echo "   (This should rarely happen - user should provide Dockerfile)"
        
        # Minimal generation as last resort
        mkdir -p "$CONTEXT_PATH"
        if [ "$STACK" = "java-maven" ] || [ "$STACK" = "java-gradle" ]; then
           JAR_FILE_PATH=$(cat .jar_path | sed "s|$CONTEXT_PATH/||")
           echo "FROM eclipse-temurin:21-jre-alpine" > "$DOCKERFILE_PATH"
           echo "WORKDIR /app" >> "$DOCKERFILE_PATH"
           echo "COPY $JAR_FILE_PATH app.jar" >> "$DOCKERFILE_PATH"
           echo 'ENTRYPOINT ["java", "-jar", "app.jar"]' >> "$DOCKERFILE_PATH"
        elif [ "$STACK" = "node" ]; then
           echo "FROM node:$NODE_VERSION" > "$DOCKERFILE_PATH"
           echo "WORKDIR /app" >> "$DOCKERFILE_PATH"
           echo "COPY . ." >> "$DOCKERFILE_PATH"
           echo "CMD [\"npm\", \"start\"]" >> "$DOCKERFILE_PATH"
        else
           echo "FROM alpine:latest" > "$DOCKERFILE_PATH"
           echo "WORKDIR /app" >> "$DOCKERFILE_PATH"
           echo "COPY . ." >> "$DOCKERFILE_PATH"
        fi
      fi

      echo "========================================="
      echo "Final Dockerfile: $DOCKERFILE_PATH"
      echo "Build Context: $CI_PROJECT_DIR/$CONTEXT_PATH"
      echo "========================================="

      echo "========================================="

    - echo "ðŸ“„ FINAL DOCKERFILE CONTENT:"
    - echo "========================================="
    - cat "$DOCKERFILE_PATH"
    - echo "========================================="

    # Authenticate and Build
    - mkdir -p /kaniko/.docker
    - AUTH_STR=$(echo -n "$DOCKER_USER:$DOCKER_PASSWORD" | base64 | tr -d '\n')
    - echo "{\"auths\":{\"https://index.docker.io/v1/\":{\"auth\":\"$AUTH_STR\"},\"index.docker.io\":{\"auth\":\"$AUTH_STR\"}}}" > /kaniko/.docker/config.json

    - |
      /kaniko/executor \
        --context "$CI_PROJECT_DIR/$CONTEXT_PATH" \
        --dockerfile "$CI_PROJECT_DIR/$DOCKERFILE_PATH" \
        --destination "$IMAGE_NAME:$TEMP_IMAGE_TAG" \
        --cache=true \
        --cache-ttl=24h \
        --snapshot-mode=redo \
        --use-new-run

# ==================================================
# 5. Container Scan (Trivy)
# ==================================================
trivy_scan:
  stage: container_scan
  image:
    name: aquasec/trivy:$TRIVY_VERSION
    entrypoint: [""]
  needs: ["build_and_push"]
  variables:
    TRIVY_USERNAME: "$DOCKER_USER"
    TRIVY_PASSWORD: "$DOCKER_PASSWORD"
    TRIVY_AUTH_URL: "https://index.docker.io/v1/"
  cache:
    key: trivy-global-cache
    paths:
      - .trivycache/
    policy: pull-push
  script:
    - IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"
    - echo "Scanning Image- $IMAGE_NAME:$TEMP_IMAGE_TAG"
    - apk add --no-cache curl jq

    - |
      if [ "$TRIVY_SCAN_MODE" = "full" ]; then
        SKIP_FLAGS=""
        TIMEOUT="30m"
      else
        SKIP_FLAGS="--skip-java-db-update"
        TIMEOUT="10m"
      fi

    # Scan
    - |
      trivy image \
        --timeout $TIMEOUT \
        --scanners vuln \
        --format json \
        --output trivy-report.json \
        --skip-db-update \
        $SKIP_FLAGS \
        --severity CRITICAL,HIGH,MEDIUM \
        --ignore-unfixed \
        "$IMAGE_NAME:$TEMP_IMAGE_TAG" || echo '{"Results":[]}' > trivy-report.json

    - |
      # Webhook Logic
      if [ -f trivy-report.json ] && [ "$ENABLE_WEBHOOKS" = "true" ]; then
        echo "Sending Trivy results to backend..."
        # (Parsing and sending logic)
      fi
  allow_failure: true
  artifacts:
    paths:
      - trivy-report.json
    when: always

# ==================================================
# 6. Release (Crane)
# ==================================================
push_to_hub:
  stage: release
  image:
    name: gcr.io/go-containerregistry/crane:$CRANE_VERSION
    entrypoint: [""]
  needs: ["trivy_scan"]
  when: manual
  script:
    - IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"
    - echo "Processing Release..."

    # Simple Security Gate (Grep based)
    - CRITICAL_COUNT=$(grep -o '"Severity":"CRITICAL"' trivy-report.json 2>/dev/null | wc -l || echo "0")
    - |
      if [ "$CRITICAL_COUNT" -gt 0 ]; then
         echo "BLOCKING RELEASE: Found $CRITICAL_COUNT CRITICAL vulnerabilities"
         exit 1
      fi

    - echo "Security Check Passed."
    - crane auth login -u "$DOCKER_USER" -p "$DOCKER_PASSWORD" index.docker.io

    - echo "Promoting image..."
    - crane cp "$IMAGE_NAME:$TEMP_IMAGE_TAG" "$IMAGE_NAME:$USER_TAG"
    - crane delete "$IMAGE_NAME:$TEMP_IMAGE_TAG" || true

    - echo "Deployment Successful- $IMAGE_NAME:$USER_TAG"

# ==================================================
# 7. Cleanup
# ==================================================
cleanup_temp_image:
  stage: cleanup
  image:
    name: gcr.io/go-containerregistry/crane:$CRANE_VERSION
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none
  script:
    - if [ -z "$DOCKER_USER" ]; then exit 0; fi
    - IMAGE_NAME="docker.io/$DOCKER_USER/$PROJECT_NAME"
    - crane auth login -u "$DOCKER_USER" -p "$DOCKER_PASSWORD" index.docker.io || true
    - crane delete "$IMAGE_NAME:$TEMP_IMAGE_TAG" || true
  when: always
