stages:
  - setup
  - security_audit
  - build_artifact
  - container_scan
  - release

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "api"
    - if: $CI_PIPELINE_SOURCE == "pipeline"
    - if: $CI_PIPELINE_SOURCE == "web"

variables:
  GITLEAKS_VERSION: "v8.18.4"
  SEMGREP_VERSION: "latest"
  TRIVY_VERSION: "0.53.0"
  KANIKO_VERSION: "v1.23.1-debug"
  CRANE_VERSION: "debug"
  
  # Default Values
  PROJECT_NAME: "${PROJECT_NAME:-scanned-project}"
  USER_TAG: "${USER_TAG:-latest}"
  
  IMAGE_NAME: index.docker.io/$DOCKER_USER/$PROJECT_NAME
  TEMP_IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  TRIVY_CACHE_DIR: ".trivycache/"
  TRIVY_NO_PROGRESS: "true"

# --- Template: Script for Cloning Code (แก้ใหม่ รองรับ Private) ---
.clone_logic: &clone_and_fix
  - echo "Initializing Git logic..."
  - if [ -z "$USER_REPO_URL" ]; then echo "USER_REPO_URL is missing"; exit 1; fi
  - if ! command -v git &> /dev/null; then apk add --no-cache git; fi
  
  # --- FIX: Logic รองรับ Private Repo ---
  - |
    if [ -n "$GIT_USERNAME" ] && [ -n "$GIT_TOKEN" ]; then
      echo "Private Repository detected. Authenticating..."
      
      # ลบ https:// หรือ http:// ออกจาก URL เดิมก่อน (เพื่อไม่ให้ซ้ำ)
      CLEAN_URL=$(echo "$USER_REPO_URL" | sed -e 's|^https://||' -e 's|^http://||')
      
      # สร้าง URL ใหม่แบบฝัง Credential: https://user:token@domain.com/repo
      git clone "https://${GIT_USERNAME}:${GIT_TOKEN}@${CLEAN_URL}" project_temp
    else
      echo "Public Repository detected (or no creds provided)."
      git clone "$USER_REPO_URL" project_temp
    fi

  - rm -rf .git
  - mv project_temp/.git .
  - cp -a project_temp/. . 
  - rm -rf project_temp
  - echo "Code cloned successfully."

# 1. Fetch Source
fetch_source_minified:
  stage: setup
  image: 
    name: alpine/git:2.45.2
    entrypoint: [""]
  retry: 2
  script:
    - *clone_and_fix
    - echo "Removing .git history to save artifact size..."
    - rm -rf .git
  artifacts:
    paths: ["."]
    expire_in: 1 hour

# 2. Gitleaks
gitleaks_scan:
  stage: security_audit
  image: 
    name: zricethezav/gitleaks:$GITLEAKS_VERSION
    entrypoint: [""]
  retry: 2
  script:
    - *clone_and_fix
    - echo "Scanning for secrets..."
    - gitleaks detect --source . -v --report-path gitleaks-report.json --exit-code 0
  allow_failure: true
  artifacts:
    paths: [gitleaks-report.json]
    when: always

# 3. Semgrep
semgrep_scan:
  stage: security_audit
  image: 
    name: returntocorp/semgrep:$SEMGREP_VERSION
    entrypoint: [""]
  retry: 2
  script:
    - *clone_and_fix
    - echo "Scanning code vulnerabilities..."
    - semgrep scan --config=p/ci --json --output=semgrep-report.json --metrics=off --verbose .
  allow_failure: true
  artifacts:
    paths: [semgrep-report.json]
    when: always

# 4. Build & Push
build_and_push:
  stage: build_artifact
  image:
    name: gcr.io/kaniko-project/executor:$KANIKO_VERSION
    entrypoint: [""]
  script:
    - echo " Starting Build Process..."

    # LOGIC Check User Dockerfile vs System Template
    - |
      if [ -f "Dockerfile" ]; then
        echo " Found User's Dockerfile! Using repository version."
        echo "   (Skipping auto-detection and template fetching)"
      else
        echo "No Dockerfile found in root."
        echo "Auto-detecting Tech Stack..."
        
        STACK="default"
        if [ -f "package.json" ]; then STACK="node"; fi
        if [ -f "requirements.txt" ] || [ -f "Pipfile" ]; then STACK="python"; fi
        if [ -f "pom.xml" ]; then STACK="java"; fi
        if [ -f "go.mod" ]; then STACK="go"; fi
        
        echo "Detected Stack: $STACK"
        echo "Fetching Template from Backend ($BACKEND_HOST_URL)..."
        
        # ติดตั้ง curl ถ้าไม่มี
        if ! command -v curl &> /dev/null; then apk add --no-cache curl; fi
        
        # ยิงไปขอ Dockerfile จาก Database ของเรา
        HTTP_STATUS=$(curl -s -o Dockerfile -w "%{http_code}" -H "x-api-key: $API_KEY" "$BACKEND_HOST_URL/api/templates?stack=$STACK")
        
        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo " Error: Failed to fetch template. Status: $HTTP_STATUS"
          echo "   Please add a Dockerfile to your repo or contact admin."
          exit 1
        fi
        
        echo "Template fetched successfully!"
      fi

    # Run Kaniko Build
    - echo "Building Docker Image..."
    
    # Setup Docker Config (Auth)
    - mkdir -p /kaniko/.docker
    - AUTH_STR=$(echo -n "$DOCKER_USER:$DOCKER_PASSWORD" | base64 | tr -d '\n')
    - echo "{\"auths\":{\"https://index.docker.io/v1/\":{\"auth\":\"$AUTH_STR\"},\"index.docker.io\":{\"auth\":\"$AUTH_STR\"}}}" > /kaniko/.docker/config.json
    
    # สั่ง Build (Kaniko จะใช้ไฟล์ชื่อ "Dockerfile" ที่อยู่ในโฟลเดอร์ปัจจุบัน)
    # ซึ่งอาจจะเป็นไฟล์ของ User หรือไฟล์ที่เราโหลดมาก็ได้
    - /kaniko/executor --context "." --dockerfile "Dockerfile" --destination $IMAGE_NAME:$TEMP_IMAGE_TAG --cache=true

# 5. Trivy
trivy_scan:
  stage: container_scan
  image: 
    name: aquasec/trivy:$TRIVY_VERSION
    entrypoint: [""]
  variables:
    TRIVY_USERNAME: "$DOCKER_USER"
    TRIVY_PASSWORD: "$DOCKER_PASSWORD"
    TRIVY_CACHE_DIR: ".trivycache/"
  cache:
    key: trivy-db-cache-protected
    paths:
      - .trivycache/
    policy: pull-push
  retry: 2
  script:
    - echo "Preparing Container Scan..."
    - if ! command -v wget &> /dev/null; then apk add --no-cache wget; fi
    - wget https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl -O html.tpl
    
    - echo "Scanning Remote Image ($IMAGE_NAME:$TEMP_IMAGE_TAG)..."
    - trivy image --format template --template "@html.tpl" -o trivy-report.html --scanners vuln $IMAGE_NAME:$TEMP_IMAGE_TAG
    - trivy image --format json -o trivy-report.json --scanners vuln $IMAGE_NAME:$TEMP_IMAGE_TAG
  allow_failure: true
  artifacts:
    paths: [trivy-report.json, trivy-report.html]
    when: always

# 6. Release
push_to_hub:
  stage: release
  image:
    name: gcr.io/go-containerregistry/crane:$CRANE_VERSION
    entrypoint: [""]
  retry: 2
  dependencies: [trivy_scan]
  script:
    - echo "Promoting image..."
    - if [ -z "$DOCKER_USER" ]; then echo "No Docker Creds, Skipping."; exit 0; fi
    
    # Debug JSON
    - echo "--- DEBUG JSON CONTENT ---"
    - if [ -f trivy-report.json ]; then head -n 20 trivy-report.json; else echo "File not found"; fi
    - echo "--------------------------"

    # Check Vulnerabilities
    - |
      CRITICAL_COUNT=0
      if [ -f trivy-report.json ]; then
        CRITICAL_COUNT=$(grep -c "Severity.*CRITICAL" trivy-report.json || true)
      fi
      
      CRITICAL_COUNT=$(echo $CRITICAL_COUNT | tr -d ' ')
      if [ -z "$CRITICAL_COUNT" ]; then CRITICAL_COUNT=0; fi
      
      echo "Found $CRITICAL_COUNT critical vulnerabilities."

      TARGET_TAG="$USER_TAG"
      if [ "$CRITICAL_COUNT" -gt 0 ]; then
        echo "CRITICAL ISSUES FOUND! Appending '-warning' to tag."
        TARGET_TAG="${USER_TAG}-warning"
      else
        echo "No critical issues. Using requested tag."
      fi

      echo "Final Image: $IMAGE_NAME:$TARGET_TAG"
      
      # 1. Login
      crane auth login -u "$DOCKER_USER" -p "$DOCKER_PASSWORD" index.docker.io
      
      # 2. Promote
      echo "Copying to final tag..."
      crane cp "$IMAGE_NAME:$TEMP_IMAGE_TAG" "$IMAGE_NAME:$TARGET_TAG"

      # 3. Cleanup
      echo "Cleaning up temporary tag ($TEMP_IMAGE_TAG)..."
      crane delete "$IMAGE_NAME:$TEMP_IMAGE_TAG" || echo "Warning: Failed to delete temp tag, but promotion succeeded."
    
  when: manual